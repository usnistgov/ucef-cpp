

// This code has been generated by the C2W code generator.
// Do not edit manually!

/*
 * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 * @author Himanshu Neema
 * @author Harmon Nine
 */

#include <boost/lexical_cast.hpp>
#include "ObjectRoot.hpp"

C2WLogger* ObjectRoot::_logger = &C2W_RTI_LOGGER_CLS::get_singleton();




void ObjectRoot::init( RTI::RTIambassador *rti ) {
	static bool isInitialized = false;
	if ( isInitialized ) {
		return;
	}
	isInitialized = true;

	

	bool isNotInitialized = true;
	while( isNotInitialized ) {
		try {
			getHandle() = rti->getObjectClassHandle( "ObjectRoot" );
			isNotInitialized = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << getInitErrorMessage() << "Federate Not Execution Member" << std::endl;
			return;				
		} catch ( RTI::NameNotFound & ) {
			std::cerr << getInitErrorMessage() << "Name Not Found" << std::endl;
			return;				
		} catch ( ... ) {
			std::cerr << getInitErrorMessage() << "Exception caught ... retry" << std::endl;
		}
	}

	getClassNameHandleMap().insert(  std::make_pair( "ObjectRoot", get_handle() )  );
	getClassHandleNameMap().insert(  std::make_pair( get_handle(), "ObjectRoot" )  );


	isNotInitialized = true;
	while( isNotInitialized ) {
		try {		
			
			
			isNotInitialized = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << getInitErrorMessage() << "Federate Not Execution Member" << std::endl;
			return;				
		} catch ( RTI::ObjectClassNotDefined & ) {
			std::cerr << getInitErrorMessage() << "Object Class Not Defined" << std::endl;
			return;				
		} catch ( RTI::NameNotFound & ) {
			std::cerr << getInitErrorMessage() << "Name Not Found" << std::endl;
			return;				
		} catch ( ... ) {
			std::cerr << getInitErrorMessage() << "Exception caught ... retry" << std::endl;
		}
	}
	

}

void ObjectRoot::publish( RTI::RTIambassador *rti ) {
	if ( getIsPublished() ) {
		return;
	}

	init( rti );

	
	getPublishedAttributeHandleSet_var().empty();
	for( StringVector::iterator stsItr = getPublishAttributeNameVector().begin() ; stsItr != getPublishAttributeNameVector().end() ; (void)++stsItr ) {
		try {
			getPublishedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( "ObjectRoot," + *stsItr )->second  );
		} catch ( ... ) {
			std::cerr << getPublishErrorMessage() << "Could not publish \"" << *stsItr + "\" attribute." << std::endl;
		}
	}


	bool isNotPublished = true;
	while( isNotPublished ) {
		try {
			rti->publishObjectClass( get_handle(), getPublishedAttributeHandleSet_var() );
			isNotPublished = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << getPublishErrorMessage() << "Federate Not Execution Member" << std::endl;
			return;
		} catch ( RTI::ObjectClassNotDefined & ) {
			std::cerr << getPublishErrorMessage() << "Object Class Not Defined" << std::endl;
			return;
		} catch ( ... ) {
			std::cerr << getPublishErrorMessage() << "Exception caught ... retry" << std::endl;
		}
	}

	getIsPublished() = true;
}

void ObjectRoot::unpublish( RTI::RTIambassador *rti ) {
	if ( !getIsPublished() ) {
		return;
	}

	init( rti );

	bool isNotUnpublished = true;
	while( isNotUnpublished ) {
		try {
			rti->unpublishObjectClass( get_handle() );
			isNotUnpublished = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << getUnpublishErrorMessage() + "Federate Not Execution Member" << std::endl;
			return;
		} catch ( RTI::ObjectClassNotDefined & ) {
			std::cerr << getUnpublishErrorMessage() + "Object Class Not Defined" << std::endl;
			return;
		} catch ( RTI::ObjectClassNotPublished & ) {
			std::cerr << getUnpublishErrorMessage() + "Object Class Not Published" << std::endl;
			return;
		} catch ( ... ) {
			std::cerr << getUnpublishErrorMessage() << "Exception caught ... retry" << std::endl;
		}
	}

	getIsPublished() = false;
}

void ObjectRoot::subscribe( RTI::RTIambassador *rti ) {
	if ( getIsSubscribed() ) {
		return;
	}

	init( rti );
	
	getSubscribedAttributeHandleSet_var().empty();
	for(  StringVector::iterator sstItr = getSubscribeAttributeNameVector().begin() ; sstItr != getSubscribeAttributeNameVector().end() ; (void)++sstItr  ) {
		try {
			getSubscribedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( "ObjectRoot," + *sstItr )->second  );
		} catch ( ... ) {
			std::cerr << getSubscribeErrorMessage() << "Could not subscribe to \"" << *sstItr << "\" attribute." << std::endl;
		}
	}

	
	bool isNotSubscribed = true;
	while( isNotSubscribed ) {
		try {
			rti->subscribeObjectClassAttributes( get_handle(), getSubscribedAttributeHandleSet_var() );
			isNotSubscribed = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << getSubscribeErrorMessage() << "Federate Not Execution Member" << std::endl;
			return;
		} catch ( RTI::ObjectClassNotDefined & ) {
			std::cerr << getSubscribeErrorMessage() << "Object Class Not Defined" << std::endl;
			return;
		} catch ( ... ) {
			std::cerr << getSubscribeErrorMessage() << "Exception caught ... retry" << std::endl;
		}
	}

	getIsSubscribed() = true;
}
	
void ObjectRoot::unsubscribe( RTI::RTIambassador *rti ) {
	if ( !getIsSubscribed() ) {
		return;
	}

	init( rti );
	
	bool isNotUnsubscribed = true;
	while( isNotUnsubscribed ) {
		try {
			rti->unsubscribeObjectClass( get_handle() );
			isNotUnsubscribed = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << getUnsubscribeErrorMessage() << "Federate Not Execution Member" << std::endl;
			return;
		} catch ( RTI::ObjectClassNotDefined & ) {
			std::cerr << getUnsubscribeErrorMessage() << "Object Class Not Defined" << std::endl;
			return;
		} catch ( RTI::ObjectClassNotSubscribed & ) {
			std::cerr << getUnsubscribeErrorMessage() << "Object Class Not Subscribed" << std::endl;
			return;
		} catch ( ... ) {
			std::cerr << getUnsubscribeErrorMessage() << "Exception caught ... retry" << std::endl;
		}
	}

	getIsSubscribed() = false;
}

bool ObjectRoot::static_init( void ) {
	static bool isInitialized = false;
	if ( isInitialized ) {
		return true;
	}
	isInitialized = true;
	
	getClassNameSet().insert( "ObjectRoot" );
	
	getClassNameFactoryMap().insert(  std::make_pair( "ObjectRoot", &ObjectRoot::factory )  );
	getClassNamePublishMap().insert(   std::make_pair(  "ObjectRoot", (PubsubFunctionPtr)( &ObjectRoot::publish )  )   );
	getClassNameUnpublishMap().insert(   std::make_pair(  "ObjectRoot", (PubsubFunctionPtr)( &ObjectRoot::unpublish )  )   );
	getClassNameSubscribeMap().insert(   std::make_pair(  "ObjectRoot", (PubsubFunctionPtr)( &ObjectRoot::subscribe )  )   );
	getClassNameUnsubscribeMap().insert(   std::make_pair(  "ObjectRoot", (PubsubFunctionPtr)( &ObjectRoot::unsubscribe )  )   );

	getDatamemberClassNameVectorPtrMap().insert(  std::make_pair( "ObjectRoot", &getDatamemberNames() )  );
	getAllDatamemberClassNameVectorPtrMap().insert(  std::make_pair( "ObjectRoot", &getAllDatamemberNames() )  );
	
	
	
	
	


	getClassNamePublishAttributeNameVectorPtrMap().insert(  std::make_pair( "ObjectRoot", &getPublishAttributeNameVector() )  );
	getClassNameSubscribeAttributeNameVectorPtrMap().insert(  std::make_pair( "ObjectRoot", &getSubscribeAttributeNameVector() )  );
	
	getClassNamePublishedAttributesPtrMap().insert(  std::make_pair( "ObjectRoot", &getPublishedAttributeHandleSet_var() )  );
	getClassNameSubscribedAttributesPtrMap().insert( std::make_pair( "ObjectRoot", &getSubscribedAttributeHandleSet_var() )  );


	return true;
}

std::ostream &operator<<( std::ostream &os, ObjectRoot::SP entitySP ) {
	return os << *entitySP;
}
std::ostream &operator<<( std::ostream &os, const ObjectRoot &entity ) {
	return os << "ObjectRoot(" 	<< ")";
}



void ObjectRoot::publish( const std::string &className, const std::string &attributeName ) {
	NameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );
	if ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {
		std::cerr << "ERROR:  ObjectRoot.publish:  could not publish class \"" << className << "\" \"" << attributeName << "\" attribute." << std::endl;
		return;
	}
	NameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );
	if ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {
		std::cerr << "ERROR:  ObjectRoot.publish:  unexpected error:  no datamember vector for class \"" << className << "\"" << std::endl;
		return;
	}
	if (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {
		std::cerr << "ERROR:  ObjectRoot.publish:  no datamember named \"" << attributeName << "\" in class \"" << className << "\"" << std::endl;
		return;
	}
	camItr->second->push_back( attributeName );
}

void ObjectRoot::subscribe( const std::string &className, const std::string &attributeName ) {
	NameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );
	if ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {
		std::cerr << "ERROR:  ObjectRoot.subscribe:  could not subscribe class \"" << className << "\" \"" << attributeName << "\" attribute." << std::endl;
		return;
	}
	NameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );
	if ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {
		std::cerr << "ERROR:  ObjectRoot.subscribe:  unexpected error:  no datamember vector for class \"" << className << "\"" << std::endl;
		return;
	}
	if (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {
		std::cerr << "ERROR:  ObjectRoot.subscribe:  no datamember named \"" << attributeName << "\" in class \"" << className << "\"" << std::endl;
		return;
	}
	camItr->second->push_back( attributeName );
}


	
ObjectRoot::SP ObjectRoot::create_object( int classHandle, const RTI::AttributeHandleValuePairSet &datamemberMap ) {
	IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );
	if ( ismItr == getClassHandleNameMap().end() ) {
		return SP( (ObjectRoot *)0 );
	}
	
	ClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );
	if ( cfmItr == getClassNameFactoryMap().end() ) {
		return SP( (ObjectRoot *)0 );
	}
	
	SP sp = (*cfmItr->second)();
	sp->setAttributes( datamemberMap );

	return sp;
}

ObjectRoot::SP ObjectRoot::create_object( int classHandle, const RTI::AttributeHandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {
	IntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );
	if ( ismItr == getClassHandleNameMap().end() ) {
		return SP( (ObjectRoot *)0 );
	}
	
	ClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );
	if ( cfmItr == getClassNameFactoryMap().end() ) {
		return SP( (ObjectRoot *)0 );
	}
	
	SP sp = (*cfmItr->second)();
	sp->setAttributes( datamemberMap );
	sp->setTime( dlc13FedTime.getTime() );

	return sp;
}



void ObjectRoot::requestUpdate( RTI::RTIambassador *rti ) {
	bool requestNotSubmitted = true;
	while( requestNotSubmitted ) {
		try {		
			rti->requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet_var() );
			requestNotSubmitted = false;
		} catch ( RTI::FederateNotExecutionMember & ) {
			std::cerr << "ERROR: " << getClassName() << "request for update failed:  Federate Not Execution Member" << std::endl;
			return;				
		} catch ( RTI::ObjectNotKnown & ) {
			std::cerr << "ERROR: " << getClassName() << "request for update failed:  Object Not Known" << std::endl;
			return;				
		} catch ( RTI::AttributeNotDefined & ) {
			std::cerr << "ERROR: " << getClassName() << "request for update failed:  Name Not Found" << std::endl;
			return;				
		} catch ( ... ) {
			std::cerr << "ERROR: " << getClassName() << "request for update failed:  Unknown Exception" << std::endl;			}
	}
}



void ObjectRoot::setAttributes( const RTI::AttributeHandleValuePairSet &datamemberMap ) {
	int size = datamemberMap.size();
	for( int ix = 0 ; ix < size ; ++ix ) {
		try {
			static RTI::ULong valueLength;
			char *value = datamemberMap.getValuePointer( ix, valueLength );
			setAttribute(  datamemberMap.getHandle( ix ), std::string( value, valueLength )  );
		} catch ( ... ) {
			std::cerr << "setAttributes: Exception caught!" << std::endl;
		}
	}
}


void ObjectRoot::registerObject( RTI::RTIambassador *rti ) {
    
    while( !_isRegistered ) {
        try {
            _object_handle = rti->registerObjectInstance( getClassHandle() );
            _isRegistered = true;
        } catch ( RTI::ObjectClassNotDefined & ) {
        	std::cerr << "ERROR:  InteractionRoot::registerObject:  Object Class Not Defined" << std::endl;
            return;
        } catch ( RTI::ObjectClassNotPublished & ) {
        	std::cerr << "ERROR:  InteractionRoot::registerObject:  Object Class Not Published" << std::endl;
            return;
        } catch ( RTI::FederateNotExecutionMember & ) {
        	std::cerr << "ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member" << std::endl;
            return;
        } catch ( ... ) {
        	std::cerr << "InteractionRoot::registerObject:  Exception caught ... retry" << std::endl;
        }
    }

}

void ObjectRoot::registerObject( RTI::RTIambassador *rti, const std::string &name ) throw ( RTI::ObjectAlreadyRegistered ) {
    while( !_isRegistered ) {
        try {
            _object_handle = rti->registerObjectInstance( getClassHandle(), name.c_str() );
            _isRegistered = true;
        } catch ( RTI::ObjectClassNotDefined & ) {
            std::cerr << "ERROR:  InteractionRoot::registerObject:  Object Class Not Defined" << std::endl;
            return;
        } catch ( RTI::ObjectClassNotPublished & ) {
            std::cerr << "ERROR:  InteractionRoot::registerObject:  Object Class Not Published" << std::endl;
            return;
        } catch ( RTI::FederateNotExecutionMember & ) {
            std::cerr << "ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member" << std::endl;
            return;
        } catch ( RTI::ObjectAlreadyRegistered & ) {
            throw;
        } catch ( ... ) {
            std::cerr << "InteractionRoot::registerObject:  Exception caught ... retry" << std::endl;
        }
    }
}

void ObjectRoot::unregisterObject( RTI::RTIambassador *rti ) {
    
    while( _isRegistered ) {
        try {
            rti->deleteObjectInstance( getObjectHandle(), 0 );
            _isRegistered = false;
        } catch ( RTI::ObjectNotKnown & ) {
        	std::cerr << "ERROR:  InteractionRoot::unregisterObject:  Object Not Known" << std::endl;
            return;
        } catch ( RTI::DeletePrivilegeNotHeld & ) {
        	std::cerr << "ERROR:  InteractionRoot::unregisterObject:  Delete Privilege Not Held" << std::endl;
            return;
        } catch ( RTI::FederateNotExecutionMember & ) {
        	std::cerr << "ERROR:  InteractionRoot::unregisterObject:  Federate Not Execution Member" << std::endl;
            return;
        } catch ( ... ) {
        	std::cerr << "InteractionRoot::unregisterObject:  Exception caught ... retry" << std::endl;
        }
    }
}

void ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, double time, bool force ) {

    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );
    if ( suppliedAttributesSP->size() == 0 ) {
    	return;
    }

    try {
        rti->updateAttributeValues(  getObjectHandle(), *suppliedAttributesSP, RTIfedTime( time ), 0  );
        createLog( time, true );
    } catch ( RTI::ObjectNotKnown & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Object Not Known" << std::endl;
        return;
    } catch ( RTI::FederateNotExecutionMember & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Federate Not Execution Member" << std::endl;
        return;
    } catch ( RTI::AttributeNotDefined & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Attribute Not Defined" << std::endl;
        return;
    } catch ( RTI::AttributeNotOwned & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Attribute Not Owned" << std::endl;
        return;
    } catch ( RTI::ConcurrentAccessAttempted & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Concurrent Access Attempted" << std::endl;
        return;
    } catch ( RTI::InvalidFederationTime & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Invalid Federation Time" << std::endl;
        return;
    } catch ( ... ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  exception caught" << std::endl;
    }
}

void ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, bool force ) {

    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );
    if ( suppliedAttributesSP->size() == 0 ) {
    	return;
    }

    try {
        rti->updateAttributeValues( getObjectHandle(), *suppliedAttributesSP, 0 );
        createLog( 0, true );
    } catch ( RTI::ObjectNotKnown & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Object Not Known" << std::endl;
        return;
    } catch ( RTI::FederateNotExecutionMember & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Federate Not Execution Member" << std::endl;
        return;
    } catch ( RTI::AttributeNotDefined & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Attribute Not Defined" << std::endl;
        return;
    } catch ( RTI::AttributeNotOwned & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Attribute Not Owned" << std::endl;
        return;
    } catch ( RTI::ConcurrentAccessAttempted & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Concurrent Access Attempted" << std::endl;
        return;
    } catch ( RTI::InvalidFederationTime & ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  Invalid Federation Time" << std::endl;
        return;
    } catch ( ... ) {
        std::cerr << "ERROR:  " << getClassName() << ":  could not update attributes:  exception caught" << std::endl;
    }
}

std::string ObjectRoot::fedName = "";

void ObjectRoot::enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel) {

	if ( globallevel.empty() ) {
		return;
	}
	if (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {
		return;
	}
	fedName = fed;
	getPubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );
	_logger->addLog( object, attribute, fed, true );
}

void ObjectRoot::enableSubscribeLog( const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {
	if ( globallevel.empty() ) {
		return;
	}
	if (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {
		return;
	}
	fedName = fed;
	getSubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );
	_logger->addLog( object, attribute, fed, false );
}

void ObjectRoot::createLog( double time, bool isPub ) {

	if ( getPubAttributeLogMap().empty() ) {
		return;
	}
	std::string id = isPub ? fedName + "_pub_" + getClassName() : getClassName() + "_sub_" + fedName;
	_logger->addLog( id, *this, time );
}


