// This file was generated by the WebGME Federates Exporter plugin. Do not edit manually!

/*
 * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 */

/*
 * 	NOTE:  ALL "if" STATEMENTS IN THIS CODE THAT HAD THE FORM:
 *
 *  if (condition) statement;
 *
 *	OR
 *
 *  if (condition) statement1;
 *  else           statement2;
 *
 *  HAVE BEEN CONVERTED TO THE FORMS:
 *
 *  if (condition) {
 *		statement;
 *	}
 *
 *	AND
 *
 *  if (condition) {
 *		statement1;
 *	} else {
 *		statement2;
 *	}
 *
 *	RESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM
 *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.
 *  -- H.S.N.
 *
 */

#ifndef _FederateObject_CLASS
#define _FederateObject_CLASS

#include "ObjectRoot.hpp"
#include "C2WException.hpp"

#include <boost/unordered_set.hpp>

class FederateObject : public ObjectRoot {
public:
	typedef ObjectRoot Super;
	typedef boost::shared_ptr< FederateObject > SP;

	static StringVector get_attribute_names() {
		return getDatamemberNames();
	}

	static StringVector get_all_attribute_names() {
		return getAllDatamemberNames();
	}

	FederateObject( void ) { }

	static SP create( void ) { return SP( new FederateObject ); }

private:
	static boost::unordered_set< std::string > m_publishedAttributeNames;

	static int &get_FederateHandle_handle_var( void ) {
		static int FederateHandle_handle;
		return FederateHandle_handle;
	}

	static int &get_FederateHost_handle_var( void ) {
		static int FederateHost_handle;
		return FederateHost_handle;
	}

	static int &get_FederateType_handle_var( void ) {
		static int FederateType_handle;
		return FederateType_handle;
	}

public:
	static int get_FederateHandle_handle( void ) { return get_FederateHandle_handle_var(); }
	static int get_FederateHost_handle( void ) { return get_FederateHost_handle_var(); }
	static int get_FederateType_handle( void ) { return get_FederateType_handle_var(); }

private:
	static int &getHandle( void ) {
		static int handle;
		return handle;
	}

public:
	static int get_handle( void ) { return getHandle(); }
	static std::string get_class_name( void ) { return "FederateObject"; }

private:
	static StringVector &getDatamemberNames( void ) {
		static StringVector datamemberNames;
		return datamemberNames;
	}

	static StringVector &getAllDatamemberNames( void ) {
		static StringVector allDatamemberNames;
		return allDatamemberNames;
	}

private:
	static RTI::AttributeHandleSet &getPublishedAttributeHandleSet_var( void ) {
		static RTI::AttributeHandleSet *publishedAttributeHandleSetPtr = RTI::AttributeHandleSetFactory::create( 3 );
		return *publishedAttributeHandleSetPtr;
	}
	static StringVector &getPublishAttributeNameVector( void ) {
		static StringVector publishAttributeNameVector;
		return publishAttributeNameVector;
	}

	static RTI::AttributeHandleSet &getSubscribedAttributeHandleSet_var( void ) {
		static RTI::AttributeHandleSet *subscribedAttributeHandleSet = RTI::AttributeHandleSetFactory::create( 3 );
		return *subscribedAttributeHandleSet;
	}
	static StringVector &getSubscribeAttributeNameVector( void ) {
		static StringVector subscribeAttributeNameVector;
		return subscribeAttributeNameVector;
	}

private:
	static ObjectRoot::SP factory( void ) {
		return ObjectRoot::SP( new FederateObject() );
	}

	static std::string &getInitErrorMessage( void ) {
		static std::string initErrorMessage( "Error:  FederateObject:  could not initialize:  " );
		return initErrorMessage;
	}

protected:
	static void init( RTI::RTIambassador *rti );

private:
	static bool &getIsPublished( void ) {
		static bool isPublished = false;
		return isPublished;
	}

	static std::string &getPublishErrorMessage( void ) {
		static std::string publishErrorMessage = "Error:  FederateObject:  could not publish:  ";
		return publishErrorMessage;
	}

public:
	static void publish( RTI::RTIambassador *rti );

private:
	static std::string &getUnpublishErrorMessage( void ) {
		static std::string unpublishErrorMessage = "Error:  FederateObject:  could not unpublish:  ";
		return unpublishErrorMessage;
	}

public:
	static void unpublish( RTI::RTIambassador *rti );

private:
	static bool &getIsSubscribed( void ) {
		static bool isSubscribed = false;
		return isSubscribed;
	}
	static std::string &getSubscribeErrorMessage( void ) {
		static std::string subscribedErrorMessage = "Error:  FederateObject:  could not subscribe:  ";
		return subscribedErrorMessage;
	}

public:
	static void subscribe( RTI::RTIambassador *rti );

private:
	static std::string getUnsubscribeErrorMessage( void ) {
		static std::string unsubscribeErrorMessage = "Error:  FederateObject:  could not unsubscribe:  ";
		return unsubscribeErrorMessage;
	}

public:
	static void unsubscribe( RTI::RTIambassador *rti );

	static bool static_init( void );

	static bool match( int handle ) { return handle == get_handle(); }

	virtual int getClassHandle( void ) const { return get_handle(); }
	virtual std::string getClassName( void ) const { return get_class_name(); }
	virtual StringVector getAttributeNames( void ) const { return get_attribute_names(); }
	virtual StringVector getAllAttributeNames( void ) const { return get_all_attribute_names(); }

	virtual std::string getAttributeName( int datamemberHandle ) const {
		if (datamemberHandle == get_FederateHandle_handle()) {
			return std::string("FederateHandle");
		} else if (datamemberHandle == get_FederateHost_handle()) {
			return std::string("FederateHost");
		} else if (datamemberHandle == get_FederateType_handle()) {
			return std::string("FederateType");
		} else {
			return ObjectRoot::getAttributeName(datamemberHandle);
		}
	}

	virtual void publishObject( RTI::RTIambassador *rti ) { publish( rti ); }
	virtual void subscribeObject( RTI::RTIambassador *rti ) { subscribe( rti ); }

	virtual ObjectRoot::SP clone( void ) {
		return ObjectRoot::SP(  new FederateObject( *this )  );
	}

	virtual const RTI::AttributeHandleSet &getSubscribedAttributeHandleSet( void ) { return getSubscribedAttributeHandleSet_var(); }

public:
	static void publish_FederateHandle( void ) {
		getPublishAttributeNameVector().push_back( "FederateHandle" );
		m_publishedAttributeNames.emplace( "FederateHandle" );
	}

	static void unpublish_FederateHandle( void ) {
		getPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), "FederateHandle" ), getPublishAttributeNameVector().end() );
		m_publishedAttributeNames.erase( "FederateHandle" );
	}

	static void subscribe_FederateHandle( void ) {
		getSubscribeAttributeNameVector().push_back( "FederateHandle" );
	}

	static void unsubscribe_FederateHandle(void ) {
		getSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), "FederateHandle" ), getSubscribeAttributeNameVector().end() );
	}

	static void publish_FederateHost( void ) {
		getPublishAttributeNameVector().push_back( "FederateHost" );
		m_publishedAttributeNames.emplace( "FederateHost" );
	}

	static void unpublish_FederateHost( void ) {
		getPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), "FederateHost" ), getPublishAttributeNameVector().end() );
		m_publishedAttributeNames.erase( "FederateHost" );
	}

	static void subscribe_FederateHost( void ) {
		getSubscribeAttributeNameVector().push_back( "FederateHost" );
	}

	static void unsubscribe_FederateHost(void ) {
		getSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), "FederateHost" ), getSubscribeAttributeNameVector().end() );
	}

	static void publish_FederateType( void ) {
		getPublishAttributeNameVector().push_back( "FederateType" );
		m_publishedAttributeNames.emplace( "FederateType" );
	}

	static void unpublish_FederateType( void ) {
		getPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), "FederateType" ), getPublishAttributeNameVector().end() );
		m_publishedAttributeNames.erase( "FederateType" );
	}

	static void subscribe_FederateType( void ) {
		getSubscribeAttributeNameVector().push_back( "FederateType" );
	}

	static void unsubscribe_FederateType(void ) {
		getSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), "FederateType" ), getSubscribeAttributeNameVector().end() );
	}

protected:
	Attribute< int, int > _FederateHandle;
	Attribute< int, std::string > _FederateHost;
	Attribute< int, std::string > _FederateType;

public:
	void set_FederateHandle( int FederateHandle ) {
		_FederateHandle.setValue( FederateHandle );
		_FederateHandle.setTime( getTime() );
	}

	int get_FederateHandle( void ) const {
		return _FederateHandle.getValue();
	}

	double get_FederateHandle_time( void ) {
		return _FederateHandle.getTime();
	}

	void set_FederateHost( const std::string & FederateHost ) {
		_FederateHost.setValue( FederateHost );
		_FederateHost.setTime( getTime() );
	}

	const std::string & get_FederateHost( void ) const {
		return _FederateHost.getValue();
	}

	double get_FederateHost_time( void ) {
		return _FederateHost.getTime();
	}

	void set_FederateType( const std::string & FederateType ) {
		_FederateType.setValue( FederateType );
		_FederateType.setTime( getTime() );
	}

	const std::string & get_FederateType( void ) const {
		return _FederateType.getValue();
	}

	double get_FederateType_time( void ) {
		return _FederateType.getTime();
	}

	FederateObject( const RTI::AttributeHandleValuePairSet &datamemberMap ) : Super( datamemberMap ) { }

	FederateObject( const RTI::AttributeHandleValuePairSet &datamemberMap, const RTIfedTime &logicalTime ) : Super( datamemberMap, logicalTime ) { }

public:
	TypeMedley getAttribute( const std::string &datamemberName ) const {
		if ( "FederateHandle" == datamemberName ) {
			return TypeMedley( get_FederateHandle() );
		} else if ( "FederateHost" == datamemberName ) {
			return TypeMedley( get_FederateHost() );
		} else if ( "FederateType" == datamemberName ) {
			return TypeMedley( get_FederateType() );
		} else {
			return Super::getAttribute( datamemberName );
		}
	}

protected:
	virtual bool setAttributeAux( const std::string &datamemberName, const std::string &val ) {
		bool retval = true;
		if ( "FederateHandle" == datamemberName ) {
			set_FederateHandle(  TypeMedley( val )  );
		} else if ( "FederateHost" == datamemberName ) {
			set_FederateHost(  TypeMedley( val )  );
		} else if ( "FederateType" == datamemberName ) {
			set_FederateType(  TypeMedley( val )  );
		} else {
			retval = Super::setAttributeAux( datamemberName, val );
		}

		return retval;
	}

	virtual bool setAttributeAux( const std::string &datamemberName, const TypeMedley &val ) {
		bool retval = true;
		if ( "FederateHandle" == datamemberName ) {
			set_FederateHandle( val );
		} else if ( "FederateHost" == datamemberName ) {
			set_FederateHost( val );
		} else if ( "FederateType" == datamemberName ) {
			set_FederateType( val );
		} else {
			retval = Super::setAttributeAux( datamemberName, val );
		}

		return retval;
	}

	virtual AttributeHandleValuePairSetSP createDatamemberHandleValuePairSet( bool force );
};

typedef FederateObject::SP FederateObjectSP;

static bool call_FederateObject_static_init = FederateObject::static_init();

std::ostream &operator<<( std::ostream &os, FederateObject::SP entitySP );
std::ostream &operator<<( std::ostream &os, const FederateObject &entity );

#endif
